---
title: Intel 启动保护
date: 2021-04-05 15:02:58
tags: Trusted Computing
---
# Backgound

能否在公司 Intel 的工作站上启用 secure boot，保证用户启动的是定制化、受管控的系统？

# 名词解释

**Platform key (PK)**: Establish a trust relationship between the platform owner (PC Manufacturer/OEM) and the firmware (UEFI BIOS) and control access to the KEK database. This is considered as the Root of Trust.

<!--more-->

**KEK**: Key Exchange Key establishes trust between Operating Systems and the platform firmware. KEK’s are installed in the platform by the OS and/or third party components which want to communicate with platform firmware.

**DB**: Authorized Database holding the public keys and certificates of the code module that is authorized to interact with platform firmware.

**DBX**: Black listed DB. Any code module that matches to these certificates will not be allowed to start loading.

**Signature**: Signature is generated by the private key and hash of the binary that will be signed.

**Certificate**: Authenticode certificate containing public key that corresponds to the private key used to sign the image.

# Secure boot流程

## Windows

当 Windows PC 加电启动时，会首先找到操作系统引导加载程序。无 Secure Boot 功能的 PC 会直接引导硬盘中的任何引导加载程序，PC 无法知道它是一个值得信赖的操作系统还是 rootkit。
当装有 UEFI 的 PC 启动时，PC 会首先验证固件是否经过数字签名，从而降低 Firmware Rootkit 的风险。如果启用 Secure Boot，固件将检查引导加载程序的数字签名并验证其是否被篡改过。如果引导加载程序完整无误，而且满足以下条件之一，固件才会启动引导程序：
* **引导程序使用受信任的证书进行了签名**。 对于经过 Windows 10 认证的 PC， Microsoft® 证书是可信的。
* **用户手动批准了引导加载程序的数字签名**。 这允许用户加载非 Microsoft 操作系统。
{% asset_img Windows-10-UEFI-Secure-Boot.jpg %}

## Linux

安全启动的工作方式要求将密钥存储在计算机主板的芯片中，并且没有集中式的方法来添加或删除此类密钥。这意味着计算机制造商将可以控制哪些软件可以在他们制造的计算机上运行。
当然，仅由于其市场主导地位，微软将始终将其密钥嵌入PC制造商的计算机中。而且，微软要求制造商包括安全启动功能，并在启用此功能的情况下装运客户端计算机，以便获得在将来的计算机上使用 Windows 8 徽标的权利。（2011-2012年）
因此其他操作系统的人指责微软造成了某种形式的垄断行为。
这个问题后来的解决方案就是微软愿意为额外引入的一个小型引导Shim提供签名，之后由Shim负责为2nd-stage bootloader进行签名验证，提供Mokmanager、mokutil工具用于证书管理
因此其他的Linux发行版，例如Ubuntu, Fedora, Red Hat Enterprise Linux, and openSUSE, 就需要将自己的证书导入Shim的数据库。
以Ubuntu启动为例，
{% asset_img ubuntu_boot.png %}
概括一下，简单来说的启动流程是：
{% codeblock %}
EFI → Shim → GRUB2 → Kernel → Kernel Module
{% endcodeblock %}
EFI信任Shim是因为Shim被Microsoft签名，证书存放在固件里
Shim验证GRUB2和Kernel是否被Canonical签名
GRUB2引导Kernel启动OS

# 理论上的方案

**方案一**：不进入secure boot，自己写一个引导，引导定制的操作系统
问题：开发成本较大，且不能保证稳定性，仍需 oem 配合签名

**方案二**：进入secure boot之后，让签名能够被验证通过

* 获得受硬件厂商认可的操作系统厂商（如Windows）的签名，问题是：

    * 微软不给签：[updated-uefi-signing-requirements](https://techcommunity.microsoft.com/t5/hardware-dev-center/updated-uefi-signing-requirements/ba-p/1062916)
    {% asset_img microsift_sign_rejection.png %}
    * shim也不给签：[shim-review](https://github.com/rhboot/shim-review)
    {% asset_img shim_review.png %}

* 微软签名了某些 bootloader（如shim，preloader），可以通过这些 bootloader 去启动我们的定制 os
问题是：攻击者也可以通过这条路往list里面加自己的签名，类似重打包

# 几种实验

## 实验1

修改bios → enable secure boot
{% asset_img 6.1a.png %}
修改shim里的secure boot state
{% codeblock lang:bash %}
sudo mokutil --enable-validation
{% endcodeblock %}
{% asset_img 6.1b.png %}

## 实验2

replace kernel with signed kernel using a key not in DB
{% codeblock lang:bash %}
$ sudo cp /boot/vmlinuz-<version>-generic.efi.signed \
          /boot/vmlinuz-<version>-generic.efi.signed.bak
$ sudo sbsign --key /etc/secureboot/key-material/test-key.rsa \
              --cert /etc/secureboot/key-material/test-cert.pem \
              --output /boot/vmlinuz-<version>-generic.efi.signed \
              /boot/vmlinuz-<version>-generic.efi.signed.bak
{% endcodeblock %}
{% asset_img 6.2.png %}

## 实验3

Enroll with the right test key
{% asset_img Enroll 6.3.gif %}

## 实验4

破坏原系统的引导，插上启动盘，即可不通过修改BIOS重装系统 → 设置bios管理员密码无效
{% asset_img 6.4.png %}
可通过关闭usb启动解决该问题，但攻击者同样可以直接对硬盘进行分区然后重装系统

# 结论
开启 secure boot 之后可以通过自签名的方式正常启动定制，但是这一行为任何拥有系统root权限的人都可以做到，因此无法禁止root用户自行签名从而修改我们的系统OS

